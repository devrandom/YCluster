<!DOCTYPE html>
<html>
<head>
    <title>Cluster Status</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        h1 { color: #333; text-align: center; }
        .refresh-info { text-align: center; color: #666; margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; background-color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        th, td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f8f9fa; font-weight: bold; }
        tr:hover { background-color: #f8f9fa; }
        .status-healthy { background-color: #d4edda; color: #155724; }
        .status-unhealthy { background-color: #f8d7da; color: #721c24; }
        .status-degraded { background-color: #fff3cd; color: #856404; }
        .status-timeout { background-color: #e2e3e5; color: #383d41; }
        .status-unreachable { background-color: #f8d7da; color: #721c24; }
        .status-error { background-color: #f8d7da; color: #721c24; }
        .status-not_required { background-color: #e7f3ff; color: #004085; }
        .status-warning { background-color: #fff3cd; color: #856404; }
        .status-critical { background-color: #f8d7da; color: #721c24; }
        .status-expired { background-color: #f8d7da; color: #721c24; }
        .status-not_configured { background-color: #e2e3e5; color: #383d41; }
        .service-cell { font-size: 0.9em; }
        .service-item { display: inline-block; margin: 2px 4px; padding: 2px 6px; border-radius: 3px; }
        .type-storage { border-left: 4px solid #007bff; }
        .type-compute { border-left: 4px solid #28a745; }
        .type-macos { border-left: 4px solid #ffc107; }
        .error-details { font-size: 0.8em; color: #666; }
        .services-container { position: relative; }
        .services-normal { display: none; }
        .services-normal.show { display: inline; }
        .services-toggle { 
            cursor: pointer; 
            color: #007bff; 
            text-decoration: underline; 
            font-size: 0.8em; 
            margin-left: 5px;
        }
        .services-toggle:hover { color: #0056b3; }
        .loading { opacity: 0.5; }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .update-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #28a745;
            border-radius: 50%;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .refresh-controls {
            text-align: center;
            margin-bottom: 20px;
        }
        .refresh-controls button {
            margin: 0 5px;
            padding: 5px 15px;
            border: 1px solid #007bff;
            background-color: white;
            color: #007bff;
            border-radius: 3px;
            cursor: pointer;
        }
        .refresh-controls button:hover {
            background-color: #007bff;
            color: white;
        }
        .refresh-controls button.active {
            background-color: #007bff;
            color: white;
        }
        .refresh-controls select {
            margin-left: 10px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .drain-button {
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 5px;
            border: none;
        }
        .drain-button.undrain {
            background-color: #28a745;
            color: white;
        }
        .drain-button.drain {
            background-color: #ffc107;
            color: black;
        }
    </style>
    <script defer src="/static/alpine-3.14.1.min.js"></script>
</head>
<body x-data="clusterStatus()" x-init="init()">
    <h1>Cluster Status Dashboard 
        <span x-show="showUpdateIndicator" x-transition.duration.2000ms class="update-indicator"></span>
    </h1>
    
    <div class="refresh-controls">
        <button @click="refreshNow()">Refresh Now</button>
        <button :class="{ active: autoRefresh }" @click="toggleAutoRefresh()">
            Auto-Refresh: <span x-text="autoRefresh ? 'ON' : 'OFF'"></span>
        </button>
        <label>Interval: 
            <select x-model.number="refreshInterval" @change="updateRefreshInterval()">
                <option value="5000">5 seconds</option>
                <option value="10000">10 seconds</option>
                <option value="30000">30 seconds</option>
                <option value="60000">1 minute</option>
                <option value="300000">5 minutes</option>
            </select>
        </label>
    </div>
    
    <!-- VIP Status Section -->
    <div style="margin-bottom: 20px;">
        <h2>Virtual IP Status</h2>
        <table style="margin-bottom: 10px;">
            <thead>
                <tr>
                    <th>VIP</th>
                    <th>Type</th>
                    <th>Status</th>
                    <th>Active On</th>
                    <th>Interface</th>
                    <th>Keepalived</th>
                </tr>
            </thead>
            <tbody>
                <template x-if="!vipStatus || !vipStatus.gateway_vip">
                    <tr><td colspan="6" style="text-align: center; color: #666;">No VIP data available</td></tr>
                </template>
                <template x-if="vipStatus && vipStatus.gateway_vip">
                    <template x-for="(vip, index) in [
                        { type: 'Gateway', data: vipStatus.gateway_vip },
                        { type: 'Storage', data: vipStatus.storage_vip }
                    ]" :key="index">
                        <tr>
                            <td><strong x-text="vip.data.ip || (vip.type === 'Gateway' ? '10.0.0.254' : '10.0.0.100')"></strong></td>
                            <td x-text="vip.type"></td>
                            <td>
                                <span :class="vip.data.active_on ? 'status-healthy' : 'status-unhealthy'" 
                                      x-text="vip.data.active_on ? 'Active' : 'Inactive'"></span>
                            </td>
                            <td>
                                <template x-if="vip.data.master_hostname">
                                    <span x-text="`${vip.data.master_hostname} (${vip.data.active_on})`"></span>
                                </template>
                                <template x-if="!vip.data.master_hostname">
                                    <span style="color: #666;">-</span>
                                </template>
                            </td>
                            <td>
                                <span x-text="vip.data.interface || '-'" :style="!vip.data.interface ? 'color: #666;' : ''"></span>
                            </td>
                            <td x-show="index === 0" :rowspan="2">
                                <template x-if="vipStatus.keepalived_nodes && vipStatus.keepalived_nodes.length > 0">
                                    <div>
                                        <span :class="keepalivedActiveCount() > 0 ? 'status-healthy' : 'status-unhealthy'"
                                              x-text="`${keepalivedActiveCount()}/${vipStatus.keepalived_nodes.length} Running`"></span>
                                        <div class="error-details" x-text="keepalivedNodeStatus()"></div>
                                    </div>
                                </template>
                                <template x-if="!vipStatus.keepalived_nodes || vipStatus.keepalived_nodes.length === 0">
                                    <span class="status-error">No keepalived data</span>
                                </template>
                            </td>
                        </tr>
                    </template>
                </template>
            </tbody>
        </table>
    </div>
    
    <h2>Node Status</h2>
    <table>
        <thead>
            <tr>
                <th>Host</th>
                <th>Type</th>
                <th>IP</th>
                <th>Leadership</th>
                <th>Drain</th>
                <th>Overall</th>
                <th>Services</th>
            </tr>
        </thead>
        <tbody>
            <template x-if="!hosts || hosts.length === 0">
                <tr><td colspan="7" style="text-align: center; color: #666;">No hosts found in cluster inventory.</td></tr>
            </template>
            <template x-for="host in hosts" :key="host.hostname">
                <tr :class="`type-${host.type} fade-in`">
                    <td><strong x-text="host.hostname"></strong></td>
                    <td x-text="host.type.charAt(0).toUpperCase() + host.type.slice(1)"></td>
                    <td x-text="host.ip"></td>
                    
                    <!-- Leadership -->
                    <td>
                        <template x-if="leadership.storage_leader === host.hostname">
                            <span class="service-item status-healthy">Storage</span>
                        </template>
                        <template x-if="leadership.dhcp_leader === host.hostname">
                            <span class="service-item status-healthy">DHCP</span>
                        </template>
                        <template x-if="leadership.storage_leader !== host.hostname && leadership.dhcp_leader !== host.hostname">
                            <span style="color: #666;">-</span>
                        </template>
                    </td>
                    
                    <!-- Drain status -->
                    <td>
                        <template x-if="hostHealth[host.hostname] && hostHealth[host.hostname].drained">
                            <div>
                                <span class="status-warning">Drained</span>
                                <button @click="toggleNodeDrain(host.hostname, false)" class="drain-button undrain">Undrain</button>
                            </div>
                        </template>
                        <template x-if="!hostHealth[host.hostname] || !hostHealth[host.hostname].drained">
                            <div>
                                <span class="status-healthy">Active</span>
                                <button @click="toggleNodeDrain(host.hostname, true)" class="drain-button drain">Drain</button>
                            </div>
                        </template>
                    </td>
                    
                    <!-- Overall status -->
                    <td>
                        <span :class="`status-${hostHealth[host.hostname]?.overall || 'error'}`" 
                              x-text="(hostHealth[host.hostname]?.overall || 'error').charAt(0).toUpperCase() + (hostHealth[host.hostname]?.overall || 'error').slice(1)"></span>
                        <template x-if="hostHealth[host.hostname]?.error">
                            <div class="error-details" x-text="hostHealth[host.hostname].error"></div>
                        </template>
                    </td>
                    
                    <!-- Services -->
                    <td class="service-cell">
                        <div class="services-container">
                            <!-- Problem services -->
                            <template x-for="service in getProblemServices(host.hostname)" :key="service.name">
                                <span :class="`service-item status-${service.status}`" x-text="service.name"></span>
                            </template>
                            
                            <!-- Normal services toggle -->
                            <template x-if="getNormalServices(host.hostname).length > 0">
                                <span class="services-toggle" 
                                      @click="toggleServices(host.hostname)"
                                      x-text="servicesExpanded[host.hostname] ? `-${getNormalServices(host.hostname).length} normal` : `+${getNormalServices(host.hostname).length} normal`">
                                </span>
                            </template>
                            
                            <!-- Normal services (collapsible) -->
                            <div :class="{ 'services-normal': true, 'show': servicesExpanded[host.hostname] }">
                                <template x-for="service in getNormalServices(host.hostname)" :key="service.name">
                                    <span :class="`service-item status-${service.status}`" x-text="service.name"></span>
                                </template>
                            </div>
                        </div>
                    </td>
                </tr>
            </template>
        </tbody>
    </table>
    <div id="drain-status" style="margin-bottom: 20px; font-size: 0.9em; color: #666;" x-html="drainStatusMessage"></div>

    <!-- Clock Skew Status Section -->
    <div style="margin-bottom: 20px;">
        <h2>Clock Synchronization</h2>
        <table style="margin-bottom: 10px;">
            <thead>
                <tr>
                    <th>Host</th>
                    <th>Status</th>
                    <th>Offset (ms)</th>
                </tr>
            </thead>
            <tbody>
                <template x-if="!hosts || hosts.length === 0">
                    <tr><td colspan="3" style="text-align: center; color: #666;">No hosts available</td></tr>
                </template>
                <template x-for="host in hosts" :key="host.hostname">
                    <tr :class="`type-${host.type}`">
                        <td><strong x-text="host.hostname"></strong></td>
                        <td>
                            <span :class="`status-${getClockSkewStatus(host.hostname)}`" 
                                  x-text="(getClockSkewStatus(host.hostname)).charAt(0).toUpperCase() + (getClockSkewStatus(host.hostname)).slice(1)"></span>
                        </td>
                        <td x-html="getClockSkewOffset(host.hostname)"></td>
                    </tr>
                </template>
            </tbody>
        </table>
    </div>

    <!-- Certificate Status Section -->
    <div style="margin-bottom: 20px;">
        <h2>TLS Certificate Status</h2>
        <table style="margin-bottom: 10px;">
            <thead>
                <tr>
                    <th>Certificate</th>
                    <th>Status</th>
                    <th>Days Until Expiry</th>
                    <th>Expires At</th>
                    <th>Subject</th>
                </tr>
            </thead>
            <tbody>
                <template x-if="!certificateStatus">
                    <tr><td colspan="5" style="text-align: center; color: #666;">No certificate data available</td></tr>
                </template>
                <template x-if="certificateStatus">
                    <tr>
                        <td><strong>Cluster Certificate</strong></td>
                        <td>
                            <span :class="getCertStatusClass()" x-text="getCertStatusText()"></span>
                            <template x-if="certificateStatus.details?.message">
                                <div class="error-details" x-text="certificateStatus.details.message"></div>
                            </template>
                        </td>
                        <td>
                            <span x-text="certificateStatus.details?.days_until_expiry ?? '-'" 
                                  :style="certificateStatus.details?.days_until_expiry === null ? 'color: #666;' : ''"></span>
                        </td>
                        <td>
                            <span x-text="certificateStatus.details?.expires_at ? certificateStatus.details.expires_at.substring(0, 19) : '-'"
                                  :style="!certificateStatus.details?.expires_at ? 'color: #666;' : ''"></span>
                        </td>
                        <td>
                            <span x-text="certificateStatus.details?.subject || '-'" 
                                  :style="!certificateStatus.details?.subject ? 'color: #666;' : 'font-size: 0.9em;'"></span>
                        </td>
                    </tr>
                </template>
            </tbody>
        </table>
    </div>
    
    <div class="refresh-info">
        <span>Last updated: <span x-text="lastUpdateTime"></span></span> | 
        <span>Served by: <span x-text="respondingNode"></span></span> | 
        <span x-text="nextUpdateText"></span>
    </div>
    
    <script>
        function clusterStatus() {
            return {
                // Data
                hosts: [],
                hostHealth: {},
                leadership: {},
                vipStatus: {},
                certificateStatus: null,
                respondingNode: 'Unknown',
                
                // UI State
                autoRefresh: true,
                refreshInterval: 10000,
                refreshTimer: null,
                countdownTimer: null,
                nextUpdateTime: null,
                lastUpdateTime: 'Never',
                nextUpdateText: 'Calculating...',
                showUpdateIndicator: false,
                servicesExpanded: {},
                drainStatusMessage: '',
                
                // Methods
                async init() {
                    await this.updateStatus();
                    this.scheduleNextUpdate();
                },
                
                async fetchStatusData() {
                    try {
                        const response = await fetch('/api/cluster-status');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return await response.json();
                    } catch (error) {
                        console.error('Error fetching status data:', error);
                        return null;
                    }
                },
                
                async updateStatus() {
                    const data = await this.fetchStatusData();
                    if (!data) {
                        console.error('Failed to fetch status data');
                        return;
                    }
                    
                    // Update all data
                    this.hosts = data.hosts || [];
                    this.hostHealth = data.hostHealth || {};
                    this.leadership = data.leadership || {};
                    this.vipStatus = data.vipStatus || {};
                    this.certificateStatus = data.certificateStatus;
                    this.respondingNode = data.respondingHostname || 'Unknown';
                    
                    // Update last update time
                    const now = new Date();
                    this.lastUpdateTime = `${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
                    
                    // Show update indicator
                    this.showUpdateIndicator = true;
                    setTimeout(() => {
                        this.showUpdateIndicator = false;
                    }, 2000);
                },
                
                scheduleNextUpdate() {
                    // Clear any existing timers
                    if (this.refreshTimer) {
                        clearTimeout(this.refreshTimer);
                        this.refreshTimer = null;
                    }
                    if (this.countdownTimer) {
                        clearInterval(this.countdownTimer);
                        this.countdownTimer = null;
                    }
                    
                    if (this.autoRefresh) {
                        // Ensure refreshInterval is a valid number
                        const interval = parseInt(this.refreshInterval);
                        if (isNaN(interval) || interval <= 0) {
                            console.error('Invalid refresh interval:', this.refreshInterval);
                            this.refreshInterval = 10000; // Default to 10 seconds
                        }
                        
                        this.nextUpdateTime = Date.now() + this.refreshInterval;
                        
                        this.refreshTimer = setTimeout(() => {
                            this.updateStatus();
                            this.scheduleNextUpdate();
                        }, this.refreshInterval);
                        
                        // Update countdown every second
                        this.countdownTimer = setInterval(() => this.updateNextUpdateTime(), 1000);
                        this.updateNextUpdateTime();
                    } else {
                        this.nextUpdateTime = null;
                        this.updateNextUpdateTime();
                    }
                },
                
                updateNextUpdateTime() {
                    if (!this.autoRefresh || !this.nextUpdateTime) {
                        this.nextUpdateText = 'Auto-refresh disabled';
                        return;
                    }
                    
                    const now = Date.now();
                    const remaining = Math.max(0, Math.floor((this.nextUpdateTime - now) / 1000));
                    
                    // Sanity check - if remaining is unreasonably large, reset
                    if (remaining > 86400) { // More than 24 hours
                        console.error('Invalid countdown detected, resetting timer');
                        this.scheduleNextUpdate();
                        return;
                    }
                },
                
                refreshNow() {
                    this.updateStatus();
                    if (this.autoRefresh) {
                        this.scheduleNextUpdate();
                    }
                },
                
                toggleAutoRefresh() {
                    this.autoRefresh = !this.autoRefresh;
                    this.scheduleNextUpdate();
                },
                
                updateRefreshInterval() {
                    // Ensure the new interval is properly parsed as a number
                    this.refreshInterval = parseInt(this.refreshInterval);
                    if (isNaN(this.refreshInterval) || this.refreshInterval <= 0) {
                        this.refreshInterval = 10000; // Default to 10 seconds
                    }
                    
                    // Reschedule with the new interval if auto-refresh is enabled
                    if (this.autoRefresh) {
                        this.scheduleNextUpdate();
                    }
                },
                
                toggleServices(hostname) {
                    this.servicesExpanded[hostname] = !this.servicesExpanded[hostname];
                },
                
                async toggleNodeDrain(hostname, shouldDrain) {
                    const action = shouldDrain ? 'Draining' : 'Undraining';
                    this.drainStatusMessage = `<span style="color: #007bff;">${action} ${hostname}...</span>`;
                    
                    const endpoint = shouldDrain ? `/api/drain/${hostname}` : `/api/undrain/${hostname}`;
                    
                    try {
                        const response = await fetch(endpoint, { method: 'POST' });
                        const data = await response.json();
                        
                        if (data.error) {
                            this.drainStatusMessage = `<span style="color: #dc3545;">Error: ${data.error}</span>`;
                        } else {
                            const status = data.status === 'drained' ? 'drained' : 'active';
                            this.drainStatusMessage = `<span style="color: #28a745;">${hostname} ${status} successfully.</span>`;
                            
                            // Refresh status immediately
                            setTimeout(() => {
                                this.updateStatus();
                                this.drainStatusMessage = '';
                            }, 2000);
                        }
                    } catch (error) {
                        this.drainStatusMessage = `<span style="color: #dc3545;">Network error: ${error.message}</span>`;
                    }
                },
                
                // Helper methods for computed values
                keepalivedActiveCount() {
                    if (!this.vipStatus.keepalived_nodes) return 0;
                    return this.vipStatus.keepalived_nodes.filter(n => n.keepalived_active).length;
                },
                
                keepalivedNodeStatus() {
                    if (!this.vipStatus.keepalived_nodes) return '';
                    return this.vipStatus.keepalived_nodes
                        .map(node => `${node.hostname}: ${node.status}`)
                        .join(', ');
                },
                
                getProblemServices(hostname) {
                    const health = this.hostHealth[hostname];
                    if (!health || !health.services) return [];
                    
                    return Object.entries(health.services)
                        .filter(([_, serviceInfo]) => {
                            const status = serviceInfo.status || 'unknown';
                            return status !== 'healthy' && status !== 'not_required';
                        })
                        .map(([name, info]) => ({
                            name,
                            status: info.status || 'unknown'
                        }));
                },
                
                getNormalServices(hostname) {
                    const health = this.hostHealth[hostname];
                    if (!health || !health.services) return [];
                    
                    return Object.entries(health.services)
                        .filter(([_, serviceInfo]) => {
                            const status = serviceInfo.status || 'unknown';
                            return status === 'healthy' || status === 'not_required';
                        })
                        .map(([name, info]) => ({
                            name,
                            status: info.status || 'unknown'
                        }));
                },
                
                getClockSkewStatus(hostname) {
                    const health = this.hostHealth[hostname];
                    if (!health || !health.services || !health.services.clock_skew) {
                        return 'error';
                    }
                    return health.services.clock_skew.status || 'error';
                },
                
                getClockSkewOffset(hostname) {
                    const health = this.hostHealth[hostname];
                    if (!health || !health.services || !health.services.clock_skew) {
                        return '<span style="color: #666;">-</span>';
                    }
                    
                    const clockSkew = health.services.clock_skew;
                    if (clockSkew.details && clockSkew.details.offset_ms !== undefined) {
                        return clockSkew.details.offset_ms;
                    } else if (clockSkew.details && clockSkew.details.message) {
                        return `<span style="color: #666;">${clockSkew.details.message}</span>`;
                    }
                    return '<span style="color: #666;">-</span>';
                },
                
                getCertStatusClass() {
                    if (!this.certificateStatus) return 'status-error';
                    const status = this.certificateStatus.status || 'error';
                    
                    const statusMap = {
                        'healthy': 'status-healthy',
                        'warning': 'status-degraded',
                        'critical': 'status-unhealthy',
                        'expired': 'status-unhealthy',
                        'not_configured': 'status-timeout',
                        'error': 'status-error'
                    };
                    
                    return statusMap[status] || 'status-error';
                },
                
                getCertStatusText() {
                    if (!this.certificateStatus) return 'Error';
                    const status = this.certificateStatus.status || 'error';
                    
                    const textMap = {
                        'healthy': 'Valid',
                        'warning': 'Expires Soon',
                        'critical': 'Critical',
                        'expired': 'Expired',
                        'not_configured': 'Not Configured',
                        'error': 'Error'
                    };
                    
                    return textMap[status] || 'Error';
                }
            }
        }
    </script>
</body>
</html>
