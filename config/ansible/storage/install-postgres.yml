---
- name: Install PostgreSQL on core nodes
  hosts: core
  become: yes
  tasks:
    - name: Install PostgreSQL packages
      apt:
        name:
          - postgresql
          - postgresql-contrib
          - python3-psycopg2
        state: present

    - name: Create PostgreSQL RBD manager script
      copy:
        dest: /usr/local/bin/postgres-rbd-manager.sh
        mode: '0755'
        content: |
          #!/bin/bash
          set -e

          POOL_NAME="rbd"
          RBD_IMAGE="psql"
          MOUNT_POINT="/rbd/pg"
          PG_DATA_DIR="/rbd/pg/data"
          LOCK_FILE="/var/run/postgres-rbd.lock"
          MAX_RETRIES=5
          RETRY_DELAY=3

          # Function to acquire RBD lock and mount
          acquire_and_mount() {
              local retries=0
              
              while [ $retries -lt $MAX_RETRIES ]; do
                  # Try to map the RBD device with exclusive lock
                  if RBD_DEVICE=$(rbd map "${POOL_NAME}/${RBD_IMAGE}" --exclusive -o osdkeepalive=6,osd_idle_ttl=10,osd_request_timeout=30); then
                      echo "Successfully locked RBD device: $RBD_DEVICE"
                      
                      # Create mount point if it doesn't exist
                      mkdir -p "$MOUNT_POINT"
                      
                      # Mount the device with optimized XFS options for network storage
                      if mount -t xfs -o noatime,nodiratime,inode64,allocsize=16M,logbufs=8,logbsize=256k,swalloc "$RBD_DEVICE" "$MOUNT_POINT" 2>/dev/null; then
                          echo "Successfully mounted $RBD_DEVICE to $MOUNT_POINT"
                          
                          # Ensure proper ownership
                          mkdir -p "$PG_DATA_DIR"
                          chown -R postgres:postgres "$MOUNT_POINT"
                          
                          # Store device info for cleanup
                          echo "$RBD_DEVICE" > "$LOCK_FILE"
                          
                          # Start PostgreSQL
                          systemctl start postgresql@16-main
                          return 0
                      else
                          echo "Failed to mount $RBD_DEVICE to $MOUNT_POINT"
                          rbd unmap "$RBD_DEVICE" 2>/dev/null || true
                      fi
                  else
                      echo "Failed to acquire exclusive lock on RBD ${POOL_NAME}/${RBD_IMAGE} (attempt $((retries + 1))/$MAX_RETRIES)"
                      
                      # Check if current lock holder exists
                      LOCK_INFO=$(rbd lock list "${POOL_NAME}/${RBD_IMAGE}" 2>/dev/null || true)
                      if [ -n "$LOCK_INFO" ]; then
                          echo "Current lock info: $LOCK_INFO"
                          
                          # Try to break stale locks if we're on retry 3 or higher
                          if [ $retries -ge 2 ]; then
                              echo "Attempting to break potentially stale locks..."
                              # Get all lock info
                              LOCK_LINES=$(rbd lock list "${POOL_NAME}/${RBD_IMAGE}" 2>/dev/null | grep -E "client\.[0-9]+" || true)
                              if [ -n "$LOCK_LINES" ]; then
                                  while IFS= read -r line; do
                                      LOCK_ID=$(echo "$line" | awk '{print $1}')
                                      LOCK_COOKIE=$(echo "$line" | awk '{print $2}')
                                      if [ -n "$LOCK_ID" ] && [ -n "$LOCK_COOKIE" ]; then
                                          echo "Attempting to remove lock: $LOCK_ID with cookie: $LOCK_COOKIE"
                                          rbd lock remove "${POOL_NAME}/${RBD_IMAGE}" "$LOCK_ID" "$LOCK_COOKIE" 2>/dev/null || true
                                      fi
                                  done <<< "$LOCK_LINES"
                              fi
                          fi
                      fi
                  fi
                  
                  retries=$((retries + 1))
                  if [ $retries -lt $MAX_RETRIES ]; then
                      echo "Retrying in $RETRY_DELAY seconds..."
                      sleep $RETRY_DELAY
                  fi
              done
              
              echo "Failed to acquire RBD lock after $MAX_RETRIES attempts"
              return 1
          }

          # Function to unmount and release RBD
          release_and_unmount() {
              # Stop PostgreSQL first
              echo "Stopping PostgreSQL service"
              systemctl stop postgresql@16-main || true
              
              if [ -f "$LOCK_FILE" ]; then
                  RBD_DEVICE=$(cat "$LOCK_FILE")
                  
                  echo "Unmounting and releasing RBD device: $RBD_DEVICE"
                  
                  # Unmount
                  umount "$MOUNT_POINT" 2>/dev/null || true
                  
                  # Unmap RBD device
                  rbd unmap "$RBD_DEVICE" 2>/dev/null || true
                  
                  # Remove lock file
                  rm -f "$LOCK_FILE"
                  
                  echo "Released RBD device: $RBD_DEVICE"
              else
                  echo "No RBD lock file found, ensuring PostgreSQL is stopped"
              fi
          }

          case "$1" in
              start)
                  if acquire_and_mount; then
                      echo "PostgreSQL RBD successfully acquired and mounted"
                      exit 0
                  else
                      echo "Failed to acquire PostgreSQL RBD lock"
                      exit 1
                  fi
                  ;;
              stop)
                  release_and_unmount
                  ;;
              *)
                  echo "Usage: $0 {start|stop}"
                  exit 1
                  ;;
          esac

    - name: Create postgres-rbd systemd service
      copy:
        dest: /etc/systemd/system/postgres-rbd.service
        content: |
          [Unit]
          Description=PostgreSQL with RBD Storage
          After=network.target

          [Service]
          Type=oneshot
          RemainAfterExit=yes
          ExecStart=/usr/local/bin/postgres-rbd-manager.sh start
          ExecStop=/usr/local/bin/postgres-rbd-manager.sh stop
          TimeoutStartSec=300
          TimeoutStopSec=60
          User=root

          [Install]
          WantedBy=multi-user.target

    - name: Update PostgreSQL data directory in config
      lineinfile:
        path: /etc/postgresql/16/main/postgresql.conf
        regexp: '^#?data_directory\s*='
        line: "data_directory = '/rbd/pg/data'"
        backup: yes

    - name: Configure PostgreSQL to listen on all addresses
      lineinfile:
        path: /etc/postgresql/16/main/postgresql.conf
        regexp: '^#?listen_addresses\s*='
        line: "listen_addresses = '*'"
        backup: yes

    - name: Configure PostgreSQL client authentication for Docker networks
      lineinfile:
        path: /etc/postgresql/16/main/pg_hba.conf
        line: "host    all             all             172.0.0.0/8             scram-sha-256"
        insertafter: "# IPv4 local connections:"
        backup: yes

    - name: Check if this node is the current storage leader
      uri:
        url: "http://{{ ansible_host }}:5000/api/health"
        method: GET
        timeout: 5
      register: health_check
      failed_when: false
      changed_when: false

    - name: Parse storage leader status
      set_fact:
        is_storage_leader: "{{ (health_check.json.storage_leader | default(false)) if health_check.status == 200 else false }}"

    - name: Disable PostgreSQL service (managed by leader election) - non-leaders only
      systemd:
        name: postgresql
        enabled: no
        state: stopped
      when: not is_storage_leader

    - name: Disable PostgreSQL@16-main service (managed by leader election) - non-leaders only
      systemd:
        name: postgresql@16-main
        enabled: no
        state: stopped
      when: not is_storage_leader

    - name: Disable PostgreSQL service for leader (but keep it running)
      systemd:
        name: postgresql
        enabled: no
      when: is_storage_leader

    - name: Disable PostgreSQL@16-main service for leader (but keep it running)
      systemd:
        name: postgresql@16-main
        enabled: no
      when: is_storage_leader

    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes

    - name: Disable postgres-rbd service (managed by leader election)
      systemd:
        name: postgres-rbd.service
        enabled: no

    - name: Temporarily start postgres-rbd to initialize database
      systemd:
        name: postgres-rbd.service
        state: started
      register: temp_start
      failed_when: false
      when: inventory_hostname == groups['core'][0]
      tags:
        - never
        - init_db

    - name: Check if PostgreSQL cluster exists at /rbd/pg/data
      stat:
        path: /rbd/pg/data/PG_VERSION
      register: cluster_exists
      when: inventory_hostname == groups['core'][0] and temp_start.failed == false
      tags:
        - never
        - init_db

    - name: Initialize PostgreSQL cluster at /rbd/pg/data
      become_user: postgres
      shell: |
        /usr/lib/postgresql/16/bin/initdb -D /rbd/pg/data
      when: inventory_hostname == groups['core'][0] and temp_start.failed == false and not cluster_exists.stat.exists
      tags:
        - never
        - init_db

    - name: Stop temporary postgres-rbd service
      systemd:
        name: postgres-rbd.service
        state: stopped
      when: inventory_hostname == groups['core'][0] and temp_start.failed == false
      tags:
        - never
        - init_db

  handlers:
    - name: restart postgresql
      systemd:
        name: postgresql@16-main
        state: restarted
