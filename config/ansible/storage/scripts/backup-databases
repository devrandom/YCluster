#!/bin/bash
set -e

BACKUP_DIR="/rbd/user/backups"
ENCRYPTED_BACKUP_DIR="/rbd/user/backups/encrypted"
POSTGRES_BACKUP_DIR="$BACKUP_DIR/postgres"
QDRANT_BACKUP_DIR="$BACKUP_DIR/qdrant"
RETENTION_DAYS=30
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Create backup directories
create_backup_dirs() {
    log "Creating backup directories..."
    mkdir -p "$POSTGRES_BACKUP_DIR"
    mkdir -p "$QDRANT_BACKUP_DIR"
    mkdir -p "$ENCRYPTED_BACKUP_DIR"
}

# Backup PostgreSQL
backup_postgres() {
    log "Starting PostgreSQL backup..."
    
    # Check if PostgreSQL is running
    if ! systemctl is-active --quiet postgresql@16-main; then
        log "PostgreSQL is not running, skipping backup"
        return 0
    fi
    
    local backup_file="$POSTGRES_BACKUP_DIR/postgres_${TIMESTAMP}.sql.gz"
    
    # Create database dump
    if sudo -u postgres pg_dumpall | gzip > "$backup_file"; then
        log "PostgreSQL backup completed: $backup_file"
        
        # Verify backup file
        if [ -s "$backup_file" ]; then
            log "PostgreSQL backup verified (size: $(du -h "$backup_file" | cut -f1))"
            
            # Encrypt backup
            local encrypted_file="$ENCRYPTED_BACKUP_DIR/postgres_${TIMESTAMP}.sql.gz.age"
            if encrypt_backup "$backup_file" "$encrypted_file"; then
                log "PostgreSQL backup encrypted successfully"
            else
                log "ERROR: PostgreSQL backup encryption failed"
                return 1
            fi
        else
            log "ERROR: PostgreSQL backup file is empty"
            rm -f "$backup_file"
            return 1
        fi
    else
        log "ERROR: PostgreSQL backup failed"
        rm -f "$backup_file"
        return 1
    fi
}

# Backup Qdrant
backup_qdrant() {
    log "Starting Qdrant backup..."
    
    # Check if Qdrant is running
    if ! systemctl is-active --quiet qdrant; then
        log "Qdrant is not running, skipping backup"
        return 0
    fi
    
    # Check if Qdrant is responding
    if ! curl -s http://localhost:6333/health >/dev/null 2>&1; then
        log "Qdrant is not responding, skipping backup"
        return 0
    fi
    
    local backup_file="$QDRANT_BACKUP_DIR/qdrant_${TIMESTAMP}.snapshot"
    
    # Create full database snapshot using Qdrant API
    log "Creating Qdrant snapshot via API..."
    local snapshot_response=$(curl -s -X POST "http://localhost:6333/snapshots" \
        -H "Content-Type: application/json" \
        -d '{}' || echo '{"status":"error"}')
    
    # Parse snapshot name from response
    local snapshot_name=$(echo "$snapshot_response" | jq -r '.result.name // empty' 2>/dev/null)
    
    if [ -z "$snapshot_name" ]; then
        log "ERROR: Failed to create Qdrant snapshot"
        log "Response: $snapshot_response"
        return 1
    fi
    
    log "Qdrant snapshot created: $snapshot_name"
    
    # Wait a moment for snapshot to be written
    sleep 2
    
    # Find the snapshot file in Qdrant's snapshots directory
    local qdrant_snapshot_dir="/rbd/user/qdrant/snapshots"
    local snapshot_file="$qdrant_snapshot_dir/$snapshot_name"
    
    if [ ! -f "$snapshot_file" ]; then
        log "ERROR: Snapshot file not found: $snapshot_file"
        return 1
    fi
    
    # Copy snapshot to backup directory
    if cp "$snapshot_file" "$backup_file"; then
        log "Qdrant backup completed: $backup_file"
        
        # Verify backup file
        if [ -s "$backup_file" ]; then
            log "Qdrant backup verified (size: $(du -h "$backup_file" | cut -f1))"
            
            # Encrypt backup
            local encrypted_file="$ENCRYPTED_BACKUP_DIR/qdrant_${TIMESTAMP}.snapshot.age"
            if encrypt_backup "$backup_file" "$encrypted_file"; then
                log "Qdrant backup encrypted successfully"
            else
                log "ERROR: Qdrant backup encryption failed"
                return 1
            fi
        else
            log "ERROR: Qdrant backup file is empty"
            rm -f "$backup_file"
            return 1
        fi
        
        # Clean up the original snapshot file to save space
        rm -f "$snapshot_file"
        log "Cleaned up original snapshot file"
        
    else
        log "ERROR: Failed to copy Qdrant snapshot"
        return 1
    fi
}

# Get backup encryption recipients from etcd
get_age_recipients() {
    local recipients_file="/tmp/age_recipients_${TIMESTAMP}"
    
    # Use ycluster CLI to get recipients
    if command -v ycluster >/dev/null 2>&1; then
        # Get recipients from etcd using JSON output and extract public keys
        ycluster backup recipients list --json 2>/dev/null | jq -r '.[].public_key // empty' 2>/dev/null | grep -v '^$' > "$recipients_file" 2>/dev/null || true
        
        if [ -s "$recipients_file" ]; then
            echo "$recipients_file"
            return 0
        fi
    fi

    rm -f "$recipients_file"
    return 1
}

# Get backup destinations from etcd
get_backup_destinations() {
    if command -v ycluster >/dev/null 2>&1; then
        # Get enabled destinations from etcd using JSON output
        ycluster backup destinations list --json 2>/dev/null | jq -r '.[] | select(.enabled == true) | .name + " " + .url' 2>/dev/null || true
    fi
}

# Sync encrypted backups to remote destinations
sync_backups() {
    log "Starting backup sync to remote destinations..."
    
    if [ ! -d "$ENCRYPTED_BACKUP_DIR" ]; then
        log "No encrypted backup directory found, nothing to sync"
        return 0
    fi
    
    local encrypted_count=$(find "$ENCRYPTED_BACKUP_DIR" -name "*.age" | wc -l)
    if [ $encrypted_count -eq 0 ]; then
        log "No encrypted backups found, nothing to sync"
        return 0
    fi
    
    # Get destinations from etcd
    local destinations=$(get_backup_destinations)
    if [ -z "$destinations" ]; then
        log "No enabled backup destinations configured"
        return 0
    fi
    
    local sync_failures=0
    local sync_successes=0
    local total_destinations=0
    
    # Process each destination
    while IFS= read -r destination_line; do
        if [ -z "$destination_line" ]; then
            continue
        fi
        
        total_destinations=$((total_destinations + 1))
        local dest_name=$(echo "$destination_line" | cut -d' ' -f1)
        local dest_url=$(echo "$destination_line" | cut -d' ' -f2-)
        
        log "Syncing to destination: $dest_name ($dest_url)"
        
        # Add trailing slash to source directory to sync contents
        local source_dir="${ENCRYPTED_BACKUP_DIR}/"
        
        if rsync -av --timeout=300 -e 'ssh -o StrictHostKeyChecking=accept-new' "$source_dir" "$dest_url" 2>&1 | while IFS= read -r line; do
            log "  rsync: $line"
        done; then
            log "Successfully synced to $dest_name"
            sync_successes=$((sync_successes + 1))
        else
            log "ERROR: Failed to sync to $dest_name"
            sync_failures=$((sync_failures + 1))
        fi
        
    done <<< "$destinations"
    
    log "Sync summary: $sync_successes/$total_destinations destinations successful"
    
    if [ $sync_failures -gt 0 ]; then
        log "ERROR: $sync_failures destination(s) failed"
        return 1
    else
        log "All destinations synced successfully"
        return 0
    fi
}

# Encrypt backup file with age
encrypt_backup() {
    local source_file="$1"
    local encrypted_file="$2"
    
    log "Encrypting backup: $(basename "$source_file")"
    
    # Get recipients
    local recipients_file
    if ! recipients_file=$(get_age_recipients); then
        log "WARNING: No age recipients found, skipping encryption"
        return 1
    fi
    
    local recipient_count=$(wc -l < "$recipients_file")
    if [ "$recipient_count" -eq 0 ]; then
        log "WARNING: No valid age recipients found, skipping encryption"
        rm -f "$recipients_file"
        return 1
    fi
    
    log "Encrypting for $recipient_count recipients"
    
    # Build age command with recipients
    local age_cmd="age"
    while IFS= read -r recipient; do
        if [ -n "$recipient" ]; then
            age_cmd="$age_cmd -r $recipient"
        fi
    done < "$recipients_file"
    
    # Encrypt the file
    if eval "$age_cmd" < "$source_file" > "$encrypted_file"; then
        log "Encryption completed: $(basename "$encrypted_file")"
        log "Encrypted file size: $(du -h "$encrypted_file" | cut -f1)"
        rm -f "$recipients_file"
        return 0
    else
        log "ERROR: Encryption failed"
        rm -f "$recipients_file" "$encrypted_file"
        return 1
    fi
}

# Clean old backups
cleanup_old_backups() {
    log "Cleaning up backups older than $RETENTION_DAYS days..."
    
    # Clean PostgreSQL backups
    if [ -d "$POSTGRES_BACKUP_DIR" ]; then
        find "$POSTGRES_BACKUP_DIR" -name "postgres_*.sql.gz" -mtime +$RETENTION_DAYS -delete
        local pg_count=$(find "$POSTGRES_BACKUP_DIR" -name "postgres_*.sql.gz" | wc -l)
        log "PostgreSQL backups remaining: $pg_count"
    fi
    
    # Clean Qdrant backups
    if [ -d "$QDRANT_BACKUP_DIR" ]; then
        find "$QDRANT_BACKUP_DIR" -name "qdrant_*.snapshot" -mtime +$RETENTION_DAYS -delete
        local qdrant_count=$(find "$QDRANT_BACKUP_DIR" -name "qdrant_*.snapshot" | wc -l)
        log "Qdrant backups remaining: $qdrant_count"
    fi
    
    # Clean encrypted backups
    if [ -d "$ENCRYPTED_BACKUP_DIR" ]; then
        find "$ENCRYPTED_BACKUP_DIR" -name "*.age" -mtime +$RETENTION_DAYS -delete
        local encrypted_count=$(find "$ENCRYPTED_BACKUP_DIR" -name "*.age" | wc -l)
        log "Encrypted backups remaining: $encrypted_count"
    fi
}

# Show backup status
show_status() {
    log "=== Backup Status ==="
    
    if [ -d "$POSTGRES_BACKUP_DIR" ]; then
        local pg_count=$(find "$POSTGRES_BACKUP_DIR" -name "postgres_*.sql.gz" | wc -l)
        local pg_size=$(du -sh "$POSTGRES_BACKUP_DIR" 2>/dev/null | cut -f1 || echo "0")
        log "PostgreSQL backups: $pg_count files, $pg_size total"
        
        if [ $pg_count -gt 0 ]; then
            local latest_pg=$(find "$POSTGRES_BACKUP_DIR" -name "postgres_*.sql.gz" -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2-)
            local latest_pg_date=$(stat -c %y "$latest_pg" 2>/dev/null | cut -d' ' -f1,2 | cut -d'.' -f1 || echo "unknown")
            log "  Latest: $(basename "$latest_pg") ($latest_pg_date)"
        fi
    fi
    
    if [ -d "$QDRANT_BACKUP_DIR" ]; then
        local qdrant_count=$(find "$QDRANT_BACKUP_DIR" -name "qdrant_*.snapshot" | wc -l)
        local qdrant_size=$(du -sh "$QDRANT_BACKUP_DIR" 2>/dev/null | cut -f1 || echo "0")
        log "Qdrant backups: $qdrant_count files, $qdrant_size total"
        
        if [ $qdrant_count -gt 0 ]; then
            local latest_qdrant=$(find "$QDRANT_BACKUP_DIR" -name "qdrant_*.snapshot" -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2-)
            local latest_qdrant_date=$(stat -c %y "$latest_qdrant" 2>/dev/null | cut -d' ' -f1,2 | cut -d'.' -f1 || echo "unknown")
            log "  Latest: $(basename "$latest_qdrant") ($latest_qdrant_date)"
        fi
    fi
    
    if [ -d "$ENCRYPTED_BACKUP_DIR" ]; then
        local encrypted_count=$(find "$ENCRYPTED_BACKUP_DIR" -name "*.age" | wc -l)
        local encrypted_size=$(du -sh "$ENCRYPTED_BACKUP_DIR" 2>/dev/null | cut -f1 || echo "0")
        log "Encrypted backups: $encrypted_count files, $encrypted_size total"
        
        if [ $encrypted_count -gt 0 ]; then
            # Show latest PostgreSQL encrypted backup
            local latest_pg_encrypted=$(find "$ENCRYPTED_BACKUP_DIR" -name "postgres_*.age" -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
            if [ -n "$latest_pg_encrypted" ]; then
                local latest_pg_encrypted_date=$(stat -c %y "$latest_pg_encrypted" 2>/dev/null | cut -d' ' -f1,2 | cut -d'.' -f1 || echo "unknown")
                log "  Latest PostgreSQL: $(basename "$latest_pg_encrypted") ($latest_pg_encrypted_date)"
            fi
            
            # Show latest Qdrant encrypted backup
            local latest_qdrant_encrypted=$(find "$ENCRYPTED_BACKUP_DIR" -name "qdrant_*.age" -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
            if [ -n "$latest_qdrant_encrypted" ]; then
                local latest_qdrant_encrypted_date=$(stat -c %y "$latest_qdrant_encrypted" 2>/dev/null | cut -d' ' -f1,2 | cut -d'.' -f1 || echo "unknown")
                log "  Latest Qdrant: $(basename "$latest_qdrant_encrypted") ($latest_qdrant_encrypted_date)"
            fi
        fi
    fi
    
    local total_size=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1 || echo "0")
    log "Total backup size: $total_size"
}

# Check if this node is the storage leader
check_storage_leader() {
    # Check if user RBD is mounted (only storage leader should have this)
    if ! mountpoint -q "/rbd/user"; then
        log "User RBD not mounted, not storage leader, skipping backup"
        exit 0
    fi
}

# Main function
main() {
    case "$1" in
        backup)
            local databases="${2:-both}"
            log "Starting database backup process for: $databases"
            check_storage_leader
            create_backup_dirs
            
            local postgres_result=0
            local qdrant_result=0
            
            case "$databases" in
                postgres|postgresql)
                    backup_postgres || postgres_result=$?
                    qdrant_result=0  # Skip Qdrant, mark as success
                    ;;
                qdrant)
                    backup_qdrant || qdrant_result=$?
                    postgres_result=0  # Skip PostgreSQL, mark as success
                    ;;
                both|all)
                    backup_postgres || postgres_result=$?
                    backup_qdrant || qdrant_result=$?
                    ;;
            esac
            
            cleanup_old_backups
            
            # Sync backups to remote destinations
            local sync_result=0
            if sync_backups; then
                log "Backup sync completed successfully"
            else
                log "Backup sync completed with errors"
                sync_result=1
            fi
            
            show_status
            
            if [ $postgres_result -eq 0 ] && [ $qdrant_result -eq 0 ] && [ $sync_result -eq 0 ]; then
                log "Backup process completed successfully"
                exit 0
            else
                log "Backup process completed with errors"
                exit 1
            fi
            ;;
        sync)
            log "Starting backup sync process"
            check_storage_leader
            
            if sync_backups; then
                log "Backup sync completed successfully"
                exit 0
            else
                log "Backup sync completed with errors"
                exit 1
            fi
            ;;
        status)
            show_status
            ;;
        cleanup)
            log "Running cleanup only..."
            cleanup_old_backups
            show_status
            ;;
        *)
            echo "Usage: $0 {backup [postgres|qdrant|both]|sync|status|cleanup}"
            echo "  backup [db] - Create backups (default: both databases)"
            echo "    postgres  - Backup PostgreSQL only"
            echo "    qdrant    - Backup Qdrant only"
            echo "    both      - Backup both databases (default)"
            echo "  sync        - Sync encrypted backups to remote destinations"
            echo "  status      - Show current backup status"
            echo "  cleanup     - Clean up old backups only"
            exit 1
            ;;
    esac
}

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    echo "This script must be run as root"
    exit 1
fi


main "$@"
