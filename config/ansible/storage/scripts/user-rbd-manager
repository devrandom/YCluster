#!/bin/bash
set -e

POOL_NAME="rbd"
RBD_IMAGE="user"
MOUNT_POINT="/rbd/user"
LOCK_FILE="/var/run/user-rbd.lock"
LUKS_MAPPER_NAME="user"
LUKS_MAPPER_PATH="/dev/mapper/${LUKS_MAPPER_NAME}"
MAX_RETRIES=5
RETRY_DELAY=3

# Helper function to get existing RBD device
get_existing_rbd_device() {
    rbd showmapped --format json | jq -r ".[] | select(.name == \"${RBD_IMAGE}\" and .pool == \"${POOL_NAME}\") | .device" 2>/dev/null || true
}

# Helper function to ensure lockfile exists
ensure_lockfile() {
    if [ ! -f "$LOCK_FILE" ]; then
        local existing_device=$(get_existing_rbd_device)
        if [ -n "$existing_device" ]; then
            echo "$existing_device" > "$LOCK_FILE"
        fi
    fi
}

# Helper function to mount filesystem
mount_filesystem() {
    local device="$1"
    mkdir -p "$MOUNT_POINT"
    if mount -t xfs -o noatime,nodiratime,inode64,allocsize=16M,logbufs=8,logbsize=256k,swalloc "$device" "$MOUNT_POINT"; then
        echo "Successfully mounted $device to $MOUNT_POINT"
        return 0
    else
        echo "Failed to mount $device to $MOUNT_POINT"
        return 1
    fi
}

# Helper function to get Tang servers for Clevis policy
get_tang_servers() {
    echo "s1:8777 s2:8777 s3:8777"
}

# Helper function to generate Clevis policy JSON
generate_clevis_policy() {
    local tang_servers=$(get_tang_servers)
    local tang_array=""
    
    for server in $tang_servers; do
        if [ -z "$tang_array" ]; then
            tang_array="{\"url\":\"http://$server\"}"
        else
            tang_array="$tang_array,{\"url\":\"http://$server\"}"
        fi
    done
    
    echo "{\"t\":2,\"pins\":{\"tang\":[$tang_array]}}"
}

# Helper function to check and bind Clevis policy
ensure_clevis_binding() {
    local device="$1"
    local passphrase_file="$2"
    
    # Verify that the passphrase can open slot 0
    if ! cryptsetup luksOpen --test-passphrase --key-slot 0 -d "$passphrase_file" "$device"; then
        echo "ERROR: Passphrase cannot open LUKS slot 0"
        return 2
    fi
    
    # Check existing bindings
    local existing_bindings=$(clevis luks list -d "$device" 2>/dev/null || echo "")
    local expected_policy=$(generate_clevis_policy)
    
    if [ -n "$existing_bindings" ]; then
        # Check if any existing binding matches our expected policy
        local policy_matches=false
        while IFS= read -r line; do
            if [[ "$line" =~ ^([0-9]+):\ sss\ \'(.*)\'$ ]]; then
                local slot="${BASH_REMATCH[1]}"
                local existing_policy="${BASH_REMATCH[2]}"
                if [ "$existing_policy" = "$expected_policy" ]; then
                    echo "Clevis binding already correct in slot $slot"
                    policy_matches=true
                elif [ "$slot" = "0" ]; then
                    echo "FATAL ERROR: Slot 0 should not have Clevis binding: $existing_policy"
                    return 2
                else
                    echo "Removing incorrect binding in slot $slot: $existing_policy"
                    if ! clevis luks unbind -d "$device" -s "$slot" -f; then
                        echo "ERROR: Failed to unbind slot $slot"
                        return 2
                    fi
                fi
            fi
        done <<< "$existing_bindings"
        
        if [ "$policy_matches" = "true" ]; then
            return 0  # No change needed
        fi
        
        echo "Clevis binding needs update"
        echo "Expected: $expected_policy"
    else
        echo "No existing Clevis bindings found"
    fi
    
    # Bind to Clevis policy
    echo "Binding LUKS device to Clevis policy..."
    if clevis luks bind -d "$device" -k "$passphrase_file" -y sss "$expected_policy"; then
        echo "Successfully bound LUKS device to Clevis"
        return 1  # Change made
    else
        echo "Failed to bind LUKS device to Clevis"
        return 2  # Error
    fi
}

# Helper function to decrypt LUKS device (shared logic)
decrypt_luks_device() {
    local rbd_device="$1"
    local use_passphrase="$2"
    local test_mode="$3"
    local mapper_name="$4"
    
    if [ "$use_passphrase" = "true" ]; then
        if [ "$test_mode" = "true" ]; then
            cryptsetup luksOpen --test-passphrase "$rbd_device"
        else
            cryptsetup luksOpen "$rbd_device" "$mapper_name"
        fi
    else
        if [ "$test_mode" = "true" ]; then
            clevis luks unlock -d "$rbd_device" -o "--test-passphrase"
        else
            clevis luks unlock -d "$rbd_device" -n "$mapper_name"
        fi
    fi
}

# Helper function to decrypt and mount LUKS device
decrypt_and_mount() {
    local rbd_device="$1"
    local use_passphrase="$2"
    
    if decrypt_luks_device "$rbd_device" "$use_passphrase" "false" "$LUKS_MAPPER_NAME"; then
        if mount_filesystem "$LUKS_MAPPER_PATH"; then
            echo "$rbd_device" > "$LOCK_FILE"
            
            # Create necessary directories for services
            mkdir -p "$MOUNT_POINT/postgres"
            mkdir -p "$MOUNT_POINT/qdrant/storage"
            mkdir -p "$MOUNT_POINT/qdrant/snapshots"
            mkdir -p "$MOUNT_POINT/backups"
            
            # Set proper ownership
            chown -R postgres:postgres "$MOUNT_POINT/postgres" || true
            chown -R qdrant:qdrant "$MOUNT_POINT/qdrant" || true
            
            return 0
        else
            cryptsetup luksClose "$LUKS_MAPPER_NAME" || true
            return 1
        fi
    else
        return 1
    fi
}

# Function to acquire RBD lock and mount
acquire_and_mount() {
    local use_passphrase="$1"
    local retries=0
    
    # Check if already mounted
    if mountpoint -q "$MOUNT_POINT"; then
        echo "Already mounted at $MOUNT_POINT"
        ensure_lockfile
        return 0
    fi
    
    # Check if LUKS device is already open
    if [ -e "$LUKS_MAPPER_PATH" ]; then
        echo "LUKS device already open at $LUKS_MAPPER_PATH"
        
        if mount_filesystem "$LUKS_MAPPER_PATH"; then
            ensure_lockfile
            return 0
        else
            return 1
        fi
    fi
    
    # Check if RBD is already mapped
    EXISTING_RBD_DEVICE=$(get_existing_rbd_device)
    if [ -n "$EXISTING_RBD_DEVICE" ]; then
        echo "RBD already mapped at $EXISTING_RBD_DEVICE"
        decrypt_and_mount "$EXISTING_RBD_DEVICE" "$use_passphrase"
        return $?
    fi
    
    while [ $retries -lt $MAX_RETRIES ]; do
        # Try to map the RBD device with exclusive lock
        if RBD_DEVICE=$(rbd map "${POOL_NAME}/${RBD_IMAGE}" --exclusive -o osdkeepalive=6,osd_idle_ttl=10,osd_request_timeout=30); then
            echo "Successfully locked RBD device: $RBD_DEVICE"
            
            if decrypt_and_mount "$RBD_DEVICE" "$use_passphrase"; then
                return 0
            else
                rbd unmap "$RBD_DEVICE" || true
            fi
        else
            echo "Failed to acquire exclusive lock on RBD ${POOL_NAME}/${RBD_IMAGE} (attempt $((retries + 1))/$MAX_RETRIES)"
            
            # Check if current lock holder exists
            LOCK_INFO=$(rbd lock list "${POOL_NAME}/${RBD_IMAGE}" --format json 2>/dev/null || echo "[]")
            if [ "$LOCK_INFO" != "[]" ] && [ -n "$LOCK_INFO" ]; then
                echo "Current lock info: $LOCK_INFO"
                
                # Try to break stale locks if we're on retry 3 or higher
                if [ $retries -ge 2 ]; then
                    echo "Attempting to break potentially stale locks..."
                    # Parse JSON lock info and remove locks
                    echo "$LOCK_INFO" | jq -r '.[] | "\(.locker) \(.cookie)"' | while read -r lock_id lock_cookie; do
                        if [ -n "$lock_id" ] && [ -n "$lock_cookie" ]; then
                            echo "Attempting to remove lock: $lock_id with cookie: $lock_cookie"
                            rbd lock remove "${POOL_NAME}/${RBD_IMAGE}" "$lock_id" "$lock_cookie" || true
                        fi
                    done
                fi
            fi
        fi
        
        retries=$((retries + 1))
        if [ $retries -lt $MAX_RETRIES ]; then
            echo "Retrying in $RETRY_DELAY seconds..."
            sleep $RETRY_DELAY
        fi
    done
    
    echo "Failed to acquire RBD lock after $MAX_RETRIES attempts"
    return 1
}

# Function to unmount and release RBD
release_and_unmount() {
    if [ -f "$LOCK_FILE" ]; then
        RBD_DEVICE=$(cat "$LOCK_FILE")
        
        echo "Unmounting and releasing RBD device: $RBD_DEVICE"
        
        # Stop services that depend on user RBD
        echo "Stopping PostgreSQL service"
        systemctl stop postgresql@16-main || true
        
        echo "Stopping Qdrant service"
        systemctl stop qdrant || true
        
        # Unmount
        umount "$MOUNT_POINT" || true
        
        # Close LUKS device
        cryptsetup luksClose "$LUKS_MAPPER_NAME" || true
        
        # Unmap RBD device
        rbd unmap "$RBD_DEVICE" || true
        
        # Remove lock file
        rm -f "$LOCK_FILE"
        
        echo "Released RBD device: $RBD_DEVICE"
    else
        echo "No RBD lock file found"
    fi
}

# Function to test if volume can be decrypted without disturbing current state
test_decrypt() {
    local use_passphrase="$1"
    echo "=== Testing User RBD Decrypt Capability ==="
    
    local rbd_info=$(rbd info "${POOL_NAME}/${RBD_IMAGE}" --format json 2>/dev/null || echo "{}")
    if [ "$rbd_info" = "{}" ]; then
        echo "ERROR: RBD volume ${POOL_NAME}/${RBD_IMAGE} does not exist"
        return 1
    fi
    
    echo "RBD volume exists: ${POOL_NAME}/${RBD_IMAGE}"
    
    # Check if RBD is already mapped
    local existing_device=$(get_existing_rbd_device)
    local test_device=""
    local mapped_by_us=false
    
    if [ -n "$existing_device" ]; then
        echo "RBD already mapped at $existing_device"
        test_device="$existing_device"
    else
        echo "Attempting to map RBD volume for testing..."
        if test_device=$(rbd map "${POOL_NAME}/${RBD_IMAGE}" --exclusive -o osdkeepalive=6,osd_idle_ttl=10,osd_request_timeout=30); then
            echo "Successfully mapped RBD device: $test_device"
            mapped_by_us=true
        else
            echo "ERROR: Failed to map RBD device (may be exclusively locked by another node)"
            return 1
        fi
    fi
    
    # Check if device is LUKS formatted
    if ! cryptsetup isLuks "$test_device"; then
        echo "ERROR: Device $test_device is not LUKS formatted"
        if [ "$mapped_by_us" = "true" ]; then
            rbd unmap "$test_device"
        fi
        return 1
    fi
    
    echo "Device is LUKS formatted"
    
    # Test decrypt capability
    local decrypt_success=false
    
    echo "Testing decrypt capability..."
    if decrypt_luks_device "$test_device" "$use_passphrase" "true"; then
        echo "SUCCESS: Volume can be decrypted"
        decrypt_success=true
    else
        echo "ERROR: Failed to decrypt volume"
    fi
    
    # Clean up: unmap RBD if we mapped it
    if [ "$mapped_by_us" = "true" ]; then
        echo "Cleaning up test mapping..."
        rbd unmap "$test_device"
    fi
    
    if [ "$decrypt_success" = "true" ]; then
        echo "Test completed successfully - volume is decryptable"
        return 0
    else
        echo "Test failed - volume cannot be decrypted"
        return 1
    fi
}

# Function to show status
show_status() {
    echo "=== User RBD Status ==="
    
    # Check mount status
    if mountpoint -q "$MOUNT_POINT"; then
        echo "Mount: MOUNTED at $MOUNT_POINT"
        df -h "$MOUNT_POINT" | tail -1 | awk '{print "  Usage: " $3 "/" $2 " (" $5 " used)"}'
    else
        echo "Mount: NOT MOUNTED"
    fi
    
    # Check LUKS status
    if [ -e "$LUKS_MAPPER_PATH" ]; then
        echo "LUKS: OPEN at $LUKS_MAPPER_PATH"
    else
        echo "LUKS: CLOSED"
    fi
    
    # Check RBD mapping status
    local existing_device=$(get_existing_rbd_device)
    if [ -n "$existing_device" ]; then
        echo "RBD: MAPPED at $existing_device"
        
        # Show lock information
        local lock_info=$(rbd lock list "${POOL_NAME}/${RBD_IMAGE}" --format json 2>/dev/null || echo "[]")
        if [ "$lock_info" != "[]" ] && [ -n "$lock_info" ]; then
            echo "  Locks:"
            echo "$lock_info" | jq -r '.[] | "    " + .locker + " (cookie: " + .cookie + ")"'
        else
            echo "  Locks: none"
        fi
    else
        echo "RBD: NOT MAPPED"
    fi
    
    # Check lock file
    if [ -f "$LOCK_FILE" ]; then
        local lock_device=$(cat "$LOCK_FILE")
        echo "Lock file: EXISTS ($lock_device)"
    else
        echo "Lock file: NOT FOUND"
    fi
    
    # Check RBD volume info
    local rbd_info=$(rbd info "${POOL_NAME}/${RBD_IMAGE}" --format json 2>/dev/null || echo "{}")
    if [ "$rbd_info" != "{}" ]; then
        local size=$(echo "$rbd_info" | jq -r '.size // "unknown"')
        local features=$(echo "$rbd_info" | jq -r '.features // [] | join(", ")')
        echo "RBD Volume: EXISTS"
        echo "  Size: $size bytes"
        echo "  Features: $features"
    else
        echo "RBD Volume: NOT FOUND"
    fi
}

# Parse command line arguments
USE_PASSPHRASE=false
COMMAND=""
PASSPHRASE_FILE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -K)
            USE_PASSPHRASE=true
            shift
            ;;
        start|stop|status|check|bind)
            COMMAND="$1"
            shift
            ;;
        -k)
            PASSPHRASE_FILE="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

if [ -z "$COMMAND" ]; then
    echo "Usage: $0 [-K] [-k FILE] {start|stop|status|check|bind}"
    echo "  start       - Acquire RBD lock and mount volume"
    echo "  stop        - Unmount volume and release RBD lock"
    echo "  status      - Show current volume status"
    echo "  check       - Test if volume can be decrypted (OK to run on mounted volume)"
    echo "  bind        - Ensure Clevis binding is correct (requires -k)"
    echo ""
    echo "Options:"
    echo "  -K          - Use LUKS passphrase instead of Clevis (for start and check commands)"
    echo "  -k FILE     - Passphrase file for bind command"
    exit 1
fi

case "$COMMAND" in
    start)
        if acquire_and_mount "$USE_PASSPHRASE"; then
            echo "User RBD successfully acquired and mounted"
            exit 0
        else
            echo "Failed to acquire User RBD lock"
            exit 1
        fi
        ;;
    stop)
        release_and_unmount
        ;;
    status)
        show_status
        ;;
    check)
        if test_decrypt "$USE_PASSPHRASE"; then
            exit 0
        else
            exit 1
        fi
        ;;
    bind)
        # Check if passphrase file is provided
        if [ -z "$PASSPHRASE_FILE" ]; then
            echo "ERROR: -k is required for bind command"
            exit 1
        fi
        
        if [ ! -f "$PASSPHRASE_FILE" ]; then
            echo "ERROR: Passphrase file $PASSPHRASE_FILE does not exist"
            exit 1
        fi
        
        # Check if RBD is already mapped
        EXISTING_RBD_DEVICE=$(get_existing_rbd_device)
        if [ -z "$EXISTING_RBD_DEVICE" ]; then
          echo "Map the rbd device first"
          exit 1
        else
            RBD_DEVICE="$EXISTING_RBD_DEVICE"
        fi
        
        # Ensure Clevis binding
        if ensure_clevis_binding "$RBD_DEVICE" "$PASSPHRASE_FILE"; then
            exit_code=$?
            if [ $exit_code -eq 0 ]; then
                echo "Clevis binding already correct"
                exit 0
            elif [ $exit_code -eq 1 ]; then
                echo "Clevis binding updated successfully"
                exit 1
            else
                echo "Clevis binding failed"
                exit 2
            fi
        else
            echo "Clevis binding failed"
            exit 2
        fi
        ;;
esac
