#!/bin/bash
set -e

# Get instance name from environment or default to empty
INSTANCE="${OPENWEBUI_INSTANCE:-}"

# Set suffix based on instance
if [ -n "$INSTANCE" ]; then
    SUFFIX="-${INSTANCE}"
else
    SUFFIX=""
fi

# Set paths and names using suffix
OPENWEBUI_DATA_DIR="/rbd/misc/app${SUFFIX}"
COMPOSE_PROJECT="open-webui${SUFFIX}"
ETCD_KEY_PREFIX="/cluster/config/open-webui${SUFFIX}"

# Function to wait for the Docker registry to be available
# This handles the race condition during storage leader failover
wait_for_registry() {
    local max_attempts=12  # 12 attempts
    local delay=5          # 5 seconds between attempts = 60s total
    local attempt=1

    while [ $attempt -le $max_attempts ]; do
        if curl -sf --max-time 3 "http://registry.xc:5000/v2/" > /dev/null 2>&1; then
            return 0
        fi
        echo "Waiting for registry (attempt $attempt/$max_attempts)..."
        sleep $delay
        attempt=$((attempt + 1))
    done

    echo "Registry not available after $((max_attempts * delay)) seconds"
    return 1
}

# Function to get or generate Open WebUI secret key from etcd
get_or_generate_secret_key() {
    local etcd_key="${ETCD_KEY_PREFIX}/secret-key"
    
    # Try to get existing key from etcd
    local existing_key=$(etcdctl get "$etcd_key" --print-value-only 2>/dev/null || true)
    
    if [ -n "$existing_key" ]; then
        echo "$existing_key"
        return 0
    fi
    
    # Generate new 63-bit secret key (8 bytes, base64 encoded)
    local new_key=$(openssl rand 8 | base64 -w 0)
    
    # Atomically store in etcd only if key doesn't exist (version == 0)
    local txn=$(cat <<EOF
version("$etcd_key") = "0"

put "$etcd_key" "$new_key"

get "$etcd_key" --print-value-only
EOF
)
    # need to echo trailing newlines because here-doc strips them
    echo -e "$txn\n\n" | etcdctl txn > /dev/null
    
    etcdctl get $etcd_key --print-value-only
}

# Function to start Open WebUI
start_openwebui() {
    # Create Open WebUI data directories with proper ownership
    # (misc-rbd.service dependency ensures /rbd/misc is mounted)
    mkdir -p "$OPENWEBUI_DATA_DIR/open-webui-data"
    chown -R openwebui:openwebui "$OPENWEBUI_DATA_DIR"

    # Get or generate secret key from etcd and write to temp file in ramdisk
    local secret_key=$(get_or_generate_secret_key)

    # Read LiteLLM master key from etcd so Open-WebUI can use LiteLLM as backend.
    # If LiteLLM isn't deployed yet the key won't exist and Open-WebUI simply
    # won't have an OpenAI-compatible backend configured â€” that is acceptable.
    local litellm_master_key
    litellm_master_key=$(etcdctl get "/cluster/config/litellm/master-key" --print-value-only 2>/dev/null || true)

    local env_file=$(mktemp --tmpdir=/dev/shm)
    
    # Set environment variables for docker-compose
    echo "OPEN_WEBUI_SECRET_KEY=$secret_key" > "$env_file"
    echo "OPENWEBUI_INSTANCE=$INSTANCE" >> "$env_file"
    echo "OPENWEBUI_DATA_DIR=$OPENWEBUI_DATA_DIR" >> "$env_file"
    echo "OPEN_WEBUI_PORT=${OPENWEBUI_PORT:-8380}" >> "$env_file"
    echo "GLOBAL_LOG_LEVEL=${GLOBAL_LOG_LEVEL:-INFO}" >> "$env_file"
    echo "LITELLM_MASTER_KEY=${litellm_master_key}" >> "$env_file"

    # Set database connection variables
    echo "OPENWEBUI_DB_USER=openwebui${SUFFIX}" >> "$env_file"
    echo "OPENWEBUI_DB_PASS=openwebui${SUFFIX}" >> "$env_file"
    echo "OPENWEBUI_DB_NAME=openwebui${SUFFIX}" >> "$env_file"
    
    # Ensure temp file is cleaned up on exit
    trap "rm -f '$env_file'" EXIT

    # Wait for registry to be available (handles storage leader failover)
    if ! wait_for_registry; then
        echo "Failed to connect to registry, aborting startup"
        return 1
    fi

    # Start Open WebUI using Docker Compose v2 with env file
    cd "/etc/open-webui${SUFFIX}"
    docker compose -p "$COMPOSE_PROJECT" --env-file "$env_file" up --pull=always
    return 0
}

# Function to stop Open WebUI
stop_openwebui() {
    echo "Stopping Open WebUI"
    
    # Stop Open WebUI using Docker Compose v2
    cd "/etc/open-webui${SUFFIX}"
    docker compose -p "$COMPOSE_PROJECT" down
    
    echo "Open WebUI stopped"
}

case "$1" in
    start)
        if start_openwebui; then
            echo "Open WebUI successfully started"
            exit 0
        else
            echo "Failed to start Open WebUI"
            exit 1
        fi
        ;;
    stop)
        stop_openwebui
        ;;
    *)
        echo "Usage: $0 {start|stop}"
        exit 1
        ;;
esac
